Encapsulate state logic into dedicated classes or modules: Your gamestate script is currently handling all game states ('play', 'menu', 'classSelect', 'gameover') logic in a single script. This is a violation of the Single Responsibility Principle and can quickly become unmanageable as your game complexity grows. Split each game state into its own separate module, e.g., 'playState', 'menuState', 'classSelectState', 'gameoverState', etc. Each of these modules should handle its own load, update and draw methods, and any specific logic.

Player Class Selection Mechanism: Move the logic for class selection into a separate module like 'classSelector'. This module should handle logic for scrolling between classes and confirming selection. Such separation would help in adding or modifying class options easily without modifying the game state code.

Camera Control: Extract the camera control logic (that is in update function now) into a separate module or class, called 'cameraController'. This module should take care of moving and constraining the camera, thus separating the concern from the game state.

Key Input Management: Input handling (the keyboard part in 'classSelect' state) could be made more modular by creating a separate 'inputController' module. It would handle all the keyboard inputs for your game, and then different modules (like 'classSelector') could check this 'inputController' to determine if an action needs to be taken.

Shop Item Logic: Similar to the class selection mechanism, you could abstract away the shop item logic into its own module 'shopManager'. It could manage available items, prices, and perhaps even player transactions.

Global Variables: You are using a few global variables such as _G.player, classes, selectedClassIndex, and shopItems. This can lead to issues in larger codebases due to accidental mutation or collision. Instead, consider encapsulating these within their relevant modules or classes. If they need to be shared across modules, consider creating a 'gameData' module that can be required where needed.

Redundant code: There's a redundancy in your update function, where you're checking twice if the player's health is less than or equal to zero to change the state to 'gameover'. This can be reduced to a single check.